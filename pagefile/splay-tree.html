<html lang="en" class="no-js">
	<head>

		<link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:300,300i,400,400i,700i" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jScrollPane/2.2.1/style/jquery.jscrollpane.min.css">
		<link rel="stylesheet" type="text/css" href="css/bookblock.css" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script>
		<link rel="stylesheet" href="css/style.css">

	</head>
	<body>
		<div id="container" class="container">

			<div class="menu-panel">
				<h3>Table of Contents</h3>
				<ul id="menu-toc" class="menu-toc">
					<li class="menu-toc-current"><a href="#item1">伸展树的介绍和定义</a></li>
					<li><a href="#item2">伸展树的旋转</a></li>
					<li><a href="#item3">伸展树的插入</a></li>
					<li><a href="#item4">伸展树的删除</a></li>
					<li><a href="#item5">伸展树的遍历</a></li>
					<li><a href="#item6">伸展树的其它操作</a></li>
				</ul>
			</div>

			<div class="bb-custom-wrapper">
				<div id="bb-bookblock" class="bb-bookblock">
					<div class="bb-item" id="item1">
						<div class="content">
							<div class="scroller">
								<br>
								<h2><a href="">伸展树的介绍和定义</a></h2>
								<br><br>
								<h3>1.伸展树的介绍</h3>								
								<p>伸展树(Splay Tree)是特殊的二叉查找树。
								它的特殊是指，它除了本身是棵二叉查找树之外，它还具备一个特点: 当某个节点被访问时，伸展树会通过旋转使该节点成为树根。这样做的好处是，下次要访问该节点时，能够迅速的访问到该节点。</p>							
								<h3>2.伸展树的基本定义</h3>								
								<p>SplayTreeNode是伸展树节点对应的类。它包括的几个组成元素:</p>								
								<ol><li>key -- 是关键字，是用来对伸展树的节点进行排序的。</li><li>left -- 是左孩子。</li><li>right -- 是右孩子。</li></ol>
								<pre><code>#ifndef _SPLAY_TREE_HPP_
#define _SPLAY_TREE_HPP_

#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;
template &lt;clsss T&gt;
class SplayTreeNode{
    public:
        T key;                // key value
        SplayTreeNode *left;    // left child
        SplayTreeNode *right;    // right child


        SplayTreeNode():left(NULL),right(NULL) {}

        SplayTreeNode(T value, SplayTreeNode *l, SplayTreeNode *r):
            key(value), left(l),right(r) {}
};</code></pre>
								<p>SplayTree是伸展树对应的类,它包括根节点mRoot和伸展树的函数接口：</p>
								<pre><code>template &lt;clsss T&gt;
class SplayTree {
    private:
        SplayTreeNode&lt;T&gt; *mRoot;    // root node

    public:
        SplayTree();
        ~SplayTree();

        // Preorder ergodic splay tree
        void preOrder();
        
        // Inorder ergodic splay tree
        void inOrder();
        
        // Postorder ergodic splay tree
        void postOrder();

        // (recursive implementation) find the node whose key value is key in the splay tree.
        SplayTreeNode&lt;T&gt;* search(T key);
        
        // (non recursive implementation) find the node whose key value is key in the splay tree.
        SplayTreeNode&lt;T&gt;* iterativeSearch(T key);

        // Find the minimum node: returns the key value of the minimum node.
        T minimum();
        
        // Find the maximum node: returns the key value of the maximum node.
        T maximum();

        // The node corresponding to the rotation key is the root node, and the return value is the root node.
        void splay(T key);

        // Insert the node (key is the node key value) into the extension tree.
        void insert(T key);

        // Delete node (key is node key value).
        void remove(T key);

        // Destroy splay tree.
        void destroy();

        // Print splay tree.
        void print();
    private:

        // Preorder ergodic splay tree
        void preOrder(SplayTreeNode&lt;T&gt;* tree) const;
        
        // Inorder ergodic splay tree
        void inOrder(SplayTreeNode&lt;T&gt;* tree) const;
        
        // Postorder ergodic splay tree
        void postOrder(SplayTreeNode&lt;T&gt;* tree) const;

        // (recursive implementation) find the node whose key value is key in the splay tree.
        SplayTreeNode&lt;T&gt;* search(SplayTreeNode&lt;T&gt;* x, T key) const;
        
        // (non recursive implementation) find the node whose key value is key in the splay tree.
        SplayTreeNode&lt;T&gt;* iterativeSearch(SplayTreeNode&lt;T&gt;* x, T key) const;

        // Find the minimum node: returns the key value of the minimum node.
        SplayTreeNode&lt;T&gt;* minimum(SplayTreeNode&lt;T&gt;* tree);
        
        // Find the maximum node: returns the key value of the maximum node.
        SplayTreeNode&lt;T&gt;* maximum(SplayTreeNode&lt;T&gt;* tree);

        // The node corresponding to the rotation key is the root node, and the return value is the root node.
        SplayTreeNode&lt;T&gt;* splay(SplayTreeNode&lt;T&gt;* tree, T key);

        // Insert node (z) into splay tree.
        SplayTreeNode&lt;T&gt;* insert(SplayTreeNode&lt;T&gt;* &tree, SplayTreeNode&lt;T&gt;* z);

        // Delete the node in the splay tree (key value is key) and return the deleted node.
        SplayTreeNode&lt;T&gt;* remove(SplayTreeNode&lt;T&gt;* &tree, T key);

        // Destroy splay tree.
        void destroy(SplayTreeNode&lt;T&gt;* &tree);

        // Parint splay tree.
        void print(SplayTreeNode&lt;T&gt;* tree, T key, int direction);
};

// Constructor
template &lt;clsss T&gt;
SplayTree&lt;T&gt;::SplayTree():mRoot(NULL)
{
}

// Destructor
template &lt;clsss T&gt;
SplayTree&lt;T&gt;::~SplayTree() 
{
    destroy(mRoot);
}</code></pre>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item2">
						<div class="content">
							<div class="scroller">
								<br>
								<h2>2.伸展树的旋转</h2>
								<br><br>
								<p>将键值为key的节点旋转为根节点，并返回根节点。它的处理情况共包括：</p>							
								<p>(a)：伸展树中存在键值为key的节点</p>	
								<p>将键值为key的节点旋转为根节点</p>								
								<p>(b)：伸展树中不存在键值为key的节点，并且key &lt; tree-&gt;key</p>								
								<ol><li>键值为key的节点的前驱节点存在的话，将键值为key的节点的前驱节点旋转为根节点</li><li>键值为key的节点的前驱节点存在的话，则意味着，key比树中任何键值都小，那么此时，将最小节点旋转为根节点</li></ol>	
								<p>(c)：伸展树中不存在键值为key的节点，并且key &gt; tree-&gt;key</p>								
								<ol><li>键值为key的节点的后继节点存在的话，将键值为key的节点的后继节点旋转为根节点</li><li>键值为key的节点的后继节点不存在的话，则意味着，key比树中任何键值都大，那么此时，将最大节点旋转为根节点</li></ol>								
								<p>下面列举个例子分别对a进行说明。
								在下面的伸展树中查找10，共包括右旋 --&gt; 右链接 --&gt; 组合这3步。</p>								
								<p>(1) 右旋</p>
								<div><img src="images/Splay tree picture/1.jpg" width="50%"/></div>								
								<p>对应代码中的rotate right部分</p>								
								<p>(2) 右链接</p>
								<div><img src="images/Splay tree picture/2.jpg" width="50%"/></div>
								<p>对应代码中的link right部分</p>								
								<p>(3) 组合</p>
								<div><img src="images/Splay tree picture/3.jpg" width="50%"/></div>
								<p>对应代码中的assemble部分</p>
								<pre><code>// The node corresponding to the rotation key is the root node, and the return value is the root node.
template &lt;clsss T&gt;
SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::splay(SplayTreeNode&lt;T&gt;* tree, T key)
{
    SplayTreeNode&lt;T&gt; N, *l, *r, *c;

    if (tree == NULL) 
        return tree;

    N.left = N.right = NULL;
    l = r = &N;

    for (;;)
    {
        if (key < tree->key)
        {
            if (tree->left == NULL)
                break;
            if (key < tree->left->key)
            {
                c = tree->left;                           /* rotate right */
                tree->left = c->right;
                c->right = tree;
                tree = c;
                if (tree->left == NULL) 
                    break;
            }
            r->left = tree;                               /* link right */
            r = tree;
            tree = tree->left;
        }
        else if (key > tree->key)
        {
            if (tree->right == NULL) 
                break;
            if (key > tree->right->key) 
            {
                c = tree->right;                          /* rotate left */
                tree->right = c->left;
                c->left = tree;
                tree = c;
                if (tree->right == NULL) 
                    break;
            }
            l->right = tree;                              /* link left */
            l = tree;
            tree = tree->right;
        }
        else
        {
            break;
        }
    }

    l->right = tree->left;                                /* assemble */
    r->left = tree->right;
    tree->left = N.right;
    tree->right = N.left;

    return tree;
}
template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::splay(T key)
{
    mRoot = splay(mRoot, key);
}</code></pre>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item3">
						<div class="content">
							<div class="scroller">
								<br>
								<h2>3.伸展树的插入</h2>
								<br><br>
								<p>insert(key)是提供给外部的接口，它的作用是新建节点(节点的键值为key)，并将节点插入到伸展树中；然后，将该节点旋转为根节点。</p>
								<p>insert(tree, z)是内部接口，它的作用是将节点z插入到tree中。insert(tree, z)在将z插入到tree中时，仅仅只将tree当作是一棵二叉查找树，而且不允许插入相同节点。</p>				
								<p>实现代码如下：</p>
								<pre><code>template &lt;clsss T&gt;
SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::insert(SplayTreeNode&lt;T&gt;* &tree, SplayTreeNode&lt;T&gt;* z)
{
    SplayTreeNode&lt;T&gt; *y = NULL;
    SplayTreeNode&lt;T&gt; *x = tree;

    // Find the insertion location of Z.
    while (x != NULL)
    {
        y = x;
        if (z->key < x->key)
            x = x->left;
        else if (z->key > x->key)
            x = x->right;
        else
        {
            cout << "Inserting the same node is not allowed(" << z->key << ")!" << endl;
            delete z;
            return tree;
        }
    }

    if (y==NULL)
        tree = z;
    else if (z->key < y->key)
        y->left = z;
    else
        y->right = z;

    return tree;
}
template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::insert(T key)
{
    SplayTreeNode&lt;T&gt; *z=NULL;

    // If the new node fails, return.
    if ((z=new SplayTreeNode&lt;T&gt;(key,NULL,NULL)) == NULL)
        return ;

    // Insertion node.
    mRoot = insert(mRoot, z);
    // Rotate the key to the root node.
    mRoot = splay(mRoot, key);
}</code></pre>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item4">
						<div class="content">
							<div class="scroller">
								<br>
								<h2>4.伸展树的删除</h2>
								<br><br>
								<p>remove(key)是外部接口，remove(tree, key)是内部接口。
								remove(tree, key)的作用是：删除伸展树中键值为key的节点。它会先在伸展树中查找键值为key的节点。若没有找到的话，则直接返回。若找到的话，则将该节点旋转为根节点，然后再删除该节点。</p>								
								<p>实现代码如下：</p>
								<pre><code>template &lt;clsss T&gt;
SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::remove(SplayTreeNode&lt;T&gt;* &tree, T key)
{
    SplayTreeNode&lt;T&gt; *x;

    if (tree == NULL) 
        return NULL;

    // Find the node whose key value is key. If not, return it directly.
    if (search(tree, key) == NULL)
        return tree;

    // Rotate the node corresponding to the key to the root node.
    tree = splay(tree, key);

    if (tree->left != NULL)
    {
        // Rotate the tree's predecessor node to the root node.
        x = splay(tree->left, key);
        // Remove tree node.
        x->right = tree->right;
    }
    else
        x = tree->right;

    delete tree;

    return x;

}
template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::remove(T key)
{
    mRoot = remove(mRoot, key);
}

// Destroy splay tree.
template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::destroy(SplayTreeNode&lt;T&gt;* &tree)
{
    if (tree==NULL)
        return ;

    if (tree->left != NULL)
        destroy(tree->left);
    if (tree->right != NULL)
        destroy(tree->right);

    delete tree;
}
template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::destroy()
{
    destroy(mRoot);
}</code></pre>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item5">
						<div class="content">
							<div class="scroller">
								<br>
								<h2>5.伸展树的遍历</h2>
								<br><br>
								<p>伸展树的遍历类似于二叉查找树，所以不再详细介绍。</p>
								<p>伸展树遍历的代码如下：</p>
								<pre><code>// Preorder ergodic splay tree
template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::preOrder(SplayTreeNode&lt;T&gt;* tree) const
{
    if(tree != NULL)
    {
        cout<< tree->key << " " ;
        preOrder(tree->left);
        preOrder(tree->right);
    }
}
template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::preOrder() 
{
    preOrder(mRoot);
}

// Inorder ergodic splay tree
template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::inOrder(SplayTreeNode&lt;T&gt;* tree) const
{
    if(tree != NULL)
    {
        inOrder(tree->left);
        cout<< tree->key << " " ;
        inOrder(tree->right);
    }
}
template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::inOrder() 
{
    inOrder(mRoot);
}

// Postorder ergodic splay tree
template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::postOrder(SplayTreeNode&lt;T&gt;* tree) const
{
    if(tree != NULL)
    {
        postOrder(tree->left);
        postOrder(tree->right);
        cout<< tree->key << " " ;
    }
}
template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::postOrder() 
{
    postOrder(mRoot);
}</code></pre>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item5">
						<div class="content">
							<div class="scroller">
								<br>
								<h2>6.伸展树的其它操作</h2>
								<br><br>
								<h3>1).查找伸展树的最大值和最小值</h3>
								<p>查找最大值和最小值的代码如下：</p>
						<pre><code>//Find the minimum node: returns the minimum node of the spanning tree whose tree is the root node.
template &lt;clsss T&gt;
SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::minimum(SplayTreeNode&lt;T&gt;* tree)
{
    if (tree == NULL)
        return NULL;

    while(tree->left != NULL)
        tree = tree->left;
    return tree;
}
template &lt;clsss T&gt;
T SplayTree&lt;T&gt;::minimum()
{
    SplayTreeNode&lt;T&gt; *p = minimum(mRoot);
    if (p != NULL)
        return p->key;

    return (T)NULL;
}
 
// Find the maximum node: returns the maximum node of the spanning tree whose tree is the root node.
template &lt;clsss T&gt;
SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::maximum(SplayTreeNode&lt;T&gt;* tree)
{
    if (tree == NULL)
        return NULL;

    while(tree->right != NULL)
        tree = tree->right;
    return tree;
}
template &lt;clsss T&gt;
T SplayTree&lt;T&gt;::maximum()
{
    SplayTreeNode&lt;T&gt; *p = maximum(mRoot);
    if (p != NULL)
        return p->key;

    return (T)NULL;
}</code></pre>
						<h3>2).查找伸展树的结点</h3>
						<p>根据值查找结点的代码如下：</p>
						<pre><code>//(recursive implementation)find the node whose key value is key in the splay tree.
template &lt;clsss T&gt;
SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(SplayTreeNode&lt;T&gt;* x, T key) const
{
    if (x==NULL || x->key==key)
        return x;

    if (key < x->key)
        return search(x->left, key);
    else
        return search(x->right, key);
}
template &lt;clsss T&gt;
SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(T key) 
{
    return search(mRoot, key);
}

// (non recursive implementation) find the node whose key value is key in the splay tree.
template &lt;clsss T&gt;
SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::iterativeSearch(SplayTreeNode&lt;T&gt;* x, T key) const
{
    while ((x!=NULL) && (x->key!=key))
    {
        if (key < x->key)
            x = x->left;
        else
            x = x->right;
    }

    return x;
}
template &lt;clsss T&gt;
SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::iterativeSearch(T key)
{
    return iterativeSearch(mRoot, key);
}</code></pre>
						<h3>3).打印伸展树的值</h3>
						<p>依次打印输出结点值的代码如下：</p>
						<pre><code>template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::print(SplayTreeNode&lt;T&gt;* tree, T key, int direction)
{
    if(tree != NULL)
    {
        if(direction==0)    // Tree is the root node.
            cout << setw(2) << tree->key << " is root" << endl;
        else                // Tree is a branch node.
            cout << setw(2) << tree->key << " is " << setw(2) << key << "'s "  << setw(12) << (direction==1?"right child" : "left child") << endl;

        print(tree->left, tree->key, -1);
        print(tree->right,tree->key,  1);
    }
}
template &lt;clsss T&gt;
void SplayTree&lt;T&gt;::print()
{
    if (mRoot != NULL)
        print(mRoot, mRoot->key, 0);
}
#endif</code></pre>
							</div>
						</div>
					</div>
				</div>

				<nav>
					<span id="bb-nav-prev">&larr;</span>
					<span id="bb-nav-next">&rarr;</span>
				</nav>

				<span id="tblcontents" class="menu-button">Table of Contents</span>

			</div>

		</div><!-- /container -->
		<script src="../js/jquery-3.1.1.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jScrollPane/2.2.1/script/jquery.jscrollpane.min.js"></script>
		<script src="js/jquery.bookblock.js"></script>
		<script src="js/page.js"></script>
		<script>
			$(function() {
				Page.init();
			});
		</script>
	</body>
</html>

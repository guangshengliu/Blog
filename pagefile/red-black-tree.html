<html lang="en" class="no-js">
	<head>

		<link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:300,300i,400,400i,700i" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jScrollPane/2.2.1/style/jquery.jscrollpane.min.css">
		<link rel="stylesheet" type="text/css" href="css/bookblock.css" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script>
		<link rel="stylesheet" href="css/style.css">

	</head>
	<body>
		<div id="container" class="container">

			<div class="menu-panel">
				<h3>Table of Contents</h3>
				<ul id="menu-toc" class="menu-toc">
					<li class="menu-toc-current"><a href="#item1">红黑树的简介</a></li>
					<li><a href="#item2">红黑树基本操作总览</a></li>
					<li><a href="#item3">红黑树的查找</a></li>
					<li><a href="#item4">红黑树的左旋和右旋</a></li>
					<li><a href="#item5">红黑树的插入</a></li>
					<li><a href="#item6">红黑树的删除</a></li>
					<li><a href="#item7">红黑树的其它操作</a></li>
					<li><a href="#item8">红黑树的遍历</a></li>
				</ul>
			</div>

			<div class="bb-custom-wrapper">
				<div id="bb-bookblock" class="bb-bookblock">
					<div class="bb-item" id="item1">
						<div class="content">
							<div class="scroller">
								<br>
								<h2><a href="">红黑树的简介</a></h2>
								<br><br>
								<p>红黑树的定义：</p>
								<p>红黑树简称R-B Tree，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红或黑。它是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary
									B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick
									修改为如今的红黑树。红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它可以在O(log
									n)时间内做查找，插入和删除，这里的n是树中元素的数目。红黑树的应用比较广泛，例如Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p>
								<p>红黑树的特征：</p>
								<ol>
									<li>每个节点或者是黑色，或者是红色。</li>
									<li>根节点是黑色。</li>
									<li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li>
									<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
									<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
								</ol>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item2">
						<div class="content">
							<div class="scroller">
								<br>
								<h2>红黑树基本操作总览</h2>
								<br><br>
								<p>RBTNode是红黑树的节点类，而RBTree对应是红黑树的操作实现类。在RBTree中包含了根节点mRoot和红黑树的相关API。在实现红黑树API的过程中，我重载了许多函数。重载的原因，一是因为有的API是内部接口，有的是外部接口；二是为了让结构更加清晰。</p>
								<p>RBTNode节点类如下：</p>
								<pre><code>#ifndef _RED_BLACK_TREE_HPP_
#define _RED_BLACK_TREE_HPP_
 
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;

enum RBTColor{RED, BLACK};
template &lt;class T&gt;
class RBTNode{
    public:
        RBTColor color;    // colour
        T key;            // Key (key value)
        RBTNode *left;    // Left child
        RBTNode *right;    // Right child
        RBTNode *parent; 	// Parent node

        RBTNode(T value, RBTColor c, RBTNode *p, RBTNode *l, RBTNode *r):
            key(value),color(c),parent(),left(l),right(r) {}
};</code></pre>
								<p>RBTree操作实现类如下：</p>
								<pre><code>template &lt;class T&gt;
class RBTree {
    private:
        RBTNode&lt;T&gt; *mRoot;    // Root node

    public:
        RBTree();
        ~RBTree();

        // Preorder traversal of Red-Black Tree.
        void preOrder();
        
        // Inorder traversal of Red-Black Tree.
        void inOrder();
        
        // Postorder traversal of Red-Black Tree.
        void postOrder();

        // (recursive implementation) find the node whose key value is key in the Red-Black Tree.
        RBTNode&lt;T&gt;* search(T key);
        
        // (non recursive implementation) find the node whose key value is key in the Red-Black Tree.
        RBTNode&lt;T&gt;* iterativeSearch(T key);

        // Find the minimum node: returns the key value of the minimum node.
        T minimum();
        
        // Find Max node: returns the key value of the max node.
        T maximum();

        // Find the successor node of node (x). That is, the data value in the Red-Black Tree is greater than the minimum node of the node.
        RBTNode&lt;T&gt;* successor(RBTNode&lt;T&gt; *x);
        
        // Find the precursor node of node (x). That is, the data value in the Red-Black Tree is less than the maximum node of the node.
        RBTNode&lt;T&gt;* predecessor(RBTNode&lt;T&gt; *x);

        // Insert the node (key is the node key value) into the Red-Black Tree.
        void insert(T key);

        // Delete node (key is node key value).
        void remove(T key);

        // Destroy the Red-Black Tree.
        void destroy();

        // Print Red-Black Tree.
        void print();
        
    private:
        // Preorder traversal of Red-Black Tree.
        void preOrder(RBTNode&lt;T&gt;* tree) const;
        
        // Inorder traversal of Red-Black Tree.
        void inOrder(RBTNode&lt;T&gt;* tree) const;
        
        // Postorder traversal of Red-Black Tree.
        void postOrder(RBTNode&lt;T&gt;* tree) const;

        // (recursive implementation) find the node whose key value is key in the Red-Black Tree.
        RBTNode&lt;T&gt;* search(RBTNode&lt;T&gt;* x, T key) const;
        
        // (non recursive implementation) find the node with key value in Red-Black Tree x
        RBTNode&lt;T&gt;* iterativeSearch(RBTNode&lt;T&gt;* x, T key) const;

        // Find the minimum node: returns the minimum node of the Red-Black Tree whose tree is the root node.
        RBTNode&lt;T&gt;* minimum(RBTNode&lt;T&gt;* tree);
        
        // Find the maximum node: returns the maximum node of the Red-Black Tree whose tree is the root node.
        RBTNode&lt;T&gt;* maximum(RBTNode&lt;T&gt;* tree);

        // Left rotation
        void leftRotate(RBTNode&lt;T&gt;* &root, RBTNode&lt;T&gt;* x);
        
        // Right rotation
        void rightRotate(RBTNode&lt;T&gt;* &root, RBTNode&lt;T&gt;* y);
        
        // Insertion function
        void insert(RBTNode&lt;T&gt;* &root, RBTNode&lt;T&gt;* node);
        
        // Insert correction function
        void insertFixUp(RBTNode&lt;T&gt;* &root, RBTNode&lt;T&gt;* node);
        
        // Delete function
        void remove(RBTNode&lt;T&gt;* &root, RBTNode&lt;T&gt; *node);
        
        // Delete correction function
        void removeFixUp(RBTNode&lt;T&gt;* &root, RBTNode&lt;T&gt; *node, RBTNode&lt;T&gt; *parent);

        // Destroy the Red-Black Tree
        void destroy(RBTNode&lt;T&gt;* &tree);

        // Print Red-Black Tree
        void print(RBTNode&lt;T&gt;* tree, T key, int direction);
 
#define rb_parent(r)   ((r)->parent)
#define rb_color(r) ((r)->color)
#define rb_is_red(r)   ((r)->color==RED)
#define rb_is_black(r)  ((r)->color==BLACK)
#define rb_set_black(r)  do { (r)->color = BLACK; } while (0)
#define rb_set_red(r)  do { (r)->color = RED; } while (0)
#define rb_set_parent(r,p)  do { (r)->parent = (p); } while (0)
#define rb_set_color(r,c)  do { (r)->color = (c); } while (0)
};// Constructor
template &lt;class T&gt;
RBTree&lt;T&gt;::RBTree():mRoot(NULL)
{
    mRoot = NULL;
}
// Destructor 
template &lt;class T&gt;
RBTree&lt;T&gt;::~RBTree() 
{
    destroy();
}</code></pre>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item3">
						<div class="content">
							<div class="scroller">
								<br>
								<h2>红黑树的查找</h2>
								<br><br>
								<p>因为红黑树是一种特殊的二叉查找树，所以红黑树的查找方法与二叉查找树基本一致,实现代码如下：</p>
								<pre><code>// (recursive implementation) find the node whose key value is key in the Red-Black Tree.
template &lt;class T&gt;
RBTNode&lt;T&gt;* RBTree&lt;T&gt;::search(RBTNode&lt;T&gt;* x, T key) const
{
    if (x==NULL || x->key==key)
        return x;

    if (key < x->key)
        return search(x->left, key);
    else
        return search(x->right, key);
}
template &lt;class T&gt;
RBTNode&lt;T&gt;* RBTree&lt;T&gt;::search(T key) 
{
    search(mRoot, key);
}

//	(non recursive implementation) find the node whose key value is key in the Red-Black Tree.
template &lt;class T&gt;
RBTNode&lt;T&gt;* RBTree&lt;T&gt;::iterativeSearch(RBTNode&lt;T&gt;* x, T key) const
{
    while ((x!=NULL) && (x->key!=key))
    {
        if (key < x->key)
            x = x->left;
        else
            x = x->right;
    }

    return x;
}

template &lt;class T&gt;
RBTNode&lt;T&gt;* RBTree&lt;T&gt;::iterativeSearch(T key)
{
    iterativeSearch(mRoot, key);
}</code></pre>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item4">
						<div class="content">
							<div class="scroller">
								<br>
								<h2>红黑树的左旋和右旋</h2>
								<br><br>
								<p>红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。旋转包括两种：左旋和右旋。下面分别对它们进行介绍。</p>
								<p>左旋调整步骤如下：</p>
								<ol>
									<li>让B的左子树成为A的右子树</li>
									<li>让A成为B的左子树</li>
									<li>将根结点设定为结点B</li>
								</ol>
								<div><img src="images/Red-Black tree picture/right.jpg" width="50%"/></div>
								<p>根据上述思路可以写出如下代码：</p>
								<pre><code>//	Left rotation
template &lt;class T&gt;
void RBTree&lt;T&gt;::leftRotate(RBTNode&lt;T&gt;* &root, RBTNode&lt;T&gt;* x)
{
    // Set the right child of X to Y.
    RBTNode&lt;T&gt; *y = x->right;
    // Set Y's left child to X's right child.
    // If y's left child is not empty, set X as the father of Y's left child.
    x->right = y->left;
    if (y->left != NULL)
        y->left->parent = x;
    // Set father of X as father of Y.
    y->parent = x->parent;
    if (x->parent == NULL)
    {
        root = y;            // If the father of X is an empty node, y is set as the root node.
    }
    else
    {
        if (x->parent->left == x)
            x->parent->left = y;    // If X is the left child of its parent, set Y as the left child of its parent.
        else
            x->parent->right = y;    // If X is the left child of its parent, set Y as the left child of its parent. 
    }    
    // Left child with X set to Y
    y->left = x;
    //Set X's parent to y
    x->parent = y;
}</code></pre>
								<p>既然有左旋，一定有右旋。事实上，右旋和左旋是对称的过程，于是可以进行左旋的反操作。</p>
								<p>右旋调整步骤如下：</p>
								<ol>
									<li>让A的右子树成为B的左子树</li>
									<li>让B成为A的左子树</li>
									<li>将根结点设定为结点A</li>
								</ol>
								<div><img src="images/Red-Black tree picture/left.jpg" width="50%"/></div>
								<p>根据上述思路可以写出如下代码：</p>
								<pre><code>//	Right rotation
template &lt;class T&gt;
void RBTree&lt;T&gt;::rightRotate(RBTNode&lt;T&gt;* &root, RBTNode&lt;T&gt;* y)
{
    // Set X to be the left child of the current node.
    RBTNode&lt;T&gt; *x = y->left;
    // Set the right child of X as the left child of Y.
    // If the right child of X is not empty, set Y as the father of the right child of X.
    y->left = x->right;
    if (x->right != NULL)
        x->right->parent = y;
    // Make Y's father X's father
    x->parent = y->parent;

    if (y->parent == NULL) 
    {
        root = x;            // If the father of Y is an empty node, X is set as the root node
    }
    else
    {
        if (y == y->parent->right)
            y->parent->right = x;    // If y is the right child of its parent, set X as the right child of Y's parent
        else
            y->parent->left = x;    // (y is the left child of its parent node) the left child of the parent node that sets x as X
    }
    // Right child with Y as X
    x->right = y;
    // Set Y's parent to X
    y->parent = x;
}</code></pre>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item5">
						<div class="content">
							<div class="scroller">
								<br>
								<h2>红黑树的插入</h2>
								<br><br>
								<p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：</p>
								<p><strong>第一步: 将红黑树当作一颗二叉查找树，将节点插入。</strong></p>
								<p>红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！</p>
								<p><strong>第二步：将插入的节点着色为&quot;红色&quot;。</strong></p>
								<p>为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：</p>
								<ol>
									<li>每个节点或者是黑色，或者是红色。</li>
									<li>根节点是黑色。</li>
									<li>每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</li>
									<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
									<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
								</ol>
								<p>将插入的节点着色为红色，不会违背&quot;特性(5)&quot;，少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可，满足了的话，它就又是一颗红黑树了。</p>
								<p><strong>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</strong></p>
								<p>第二步中，将插入节点着色为&quot;红色&quot;之后，不会违背&quot;特性(5)&quot;。那它到底会违背哪些特性呢？
									对于&quot;特性(1)&quot;，显然不会违背了。因为我们已经将它涂成红色了。</p>
								<p>对于&quot;特性(2)&quot;，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。</p>
								<p>对于&quot;特性(3)&quot;，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。</p>
								<p>对于&quot;特性(4)&quot;，是有可能违背的！那接下来，想办法使之&quot;满足特性(4)&quot;，就可以将树重新构造成红黑树了。</p>
								<p>根据被插入节点的父节点的情况，可以将&quot;当节点z被着色为红色节点，并插入二叉树&quot;划分为三种情况来处理。</p>
								<ol>
									<li>情况说明：被插入的节点是根节点。
										处理方法：直接把此节点涂为黑色。</li>
									<li>情况说明：被插入的节点的父节点是黑色。
										处理方法：什么也不需要做。节点被插入后，仍然是红黑树。</li>
									<li>情况说明：被插入的节点的父节点是红色。
										处理方法：那么，该情况与红黑树的特性(5)相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据&quot;叔叔节点的情况&quot;，将这种情况进一步划分为3种情况(Case)。</li>
								</ol>
								<table frame="border" rules="all">
									<tr align="center">
										<th></th>
										<th>现象描述</th>
										<th>处理策略</th>
									</tr>
									<tr>
										<td>Case 1</td>
										<td>当前节点的父节点是红色的，当前节点的祖父节点的另一个子节点（叔叔节点）也为红色</td>
										<td>(1) 将父节点设置为黑色</br>(2) 将叔叔节点设置为黑色</br>(3) 将祖父节点设置为红色</br>(4)
											将祖父节点设为当前节点，继续对当前节点进行操作</td>
									</tr>
									<tr>
										<td>Case 2</td>
										<td>当前节点的父节点为红色，叔叔节点为黑色，当前节点为其父节点的右孩子</td>
										<td>(1) 将父节点作为新的当前节点</br>(2) 以新的当前节点为支点进行左旋</td>
									</tr>
									<tr>
										<td>Case 3</td>
										<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</td>
										<td>(1) 将父节点设为黑色</br>(2) 将祖父节点设为红色</br>(3) 以祖父节点为支点进行右旋</td>
									</tr>
								</table>
								<p><strong>(Case 1)叔叔是红色</strong></p>
								<p>1.1 现象说明</p>
								<p>当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</p>
								<p>1.2 处理策略</p>
								<p>(1) 将父节点设为黑色。
									(2) 将叔叔节点设为黑色。
									(3) 将祖父节点设为红色。
									(4) 将祖父节点设为当前节点(红色节点)；即，之后继续对当前节点进行操作。</p>
								<p>下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p>
								<p>当前节点和父节点都是红色，违背特性(4)。所以，将父节点设置黑色以解决这个问题。
									但是，将父节点由红色变成黑色之后，违背了特性(5)：因为，包含父节点的分支的黑色节点的总数增加了1。
									解决这个问题的办法是：将祖父节点由黑色变成红色，同时，将叔叔节点由红色变成黑色。关于这里，说明几点：</p>
								<p>第一，为什么祖父节点之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，父节点是红色，那么祖父节点一定是黑色。</p>
								<p>第二，为什么将祖父节点由黑色变成红色，同时，将叔叔节点由红色变成黑色；能解决包含‘父节点’的分支的黑色节点的总数增加了1的问题。这个道理也很简单。包含‘父节点’的分支的黑色节点的总数增加了1
									同时也意味着 包含‘祖父节点’的分支的黑色节点的总数增加了1，既然这样，我们通过将祖父节点由黑色变成红色以解决包含‘祖父节点’的分支的黑色节点的总数增加了1的问题；
									但是，这样处理之后又会引起另一个问题包含‘叔叔’节点的分支的黑色节点的总数减少了1，现在我们已知叔叔节点是红色，将叔叔节点设为黑色就能解决这个问题。
									所以，将祖父节点由黑色变成红色，同时，将叔叔节点由红色变成黑色；就解决了该问题。</p>
								<p>按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为黑色，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将祖父节点设为新的当前节点，接着对新的当前节点进行分析。</p>
								<p>1.3 示意图</p>
								<div><img src="images/Red-Black tree picture/insert1.jpg" width="50%"/></div>
								<p><strong>(Case 2)叔叔是黑色，且当前节点是右孩子</strong></p>
								<p>2.1 现象说明</p>
								<p>当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子。</p>
								<p>2.2 处理策略</p>
								<p>(01) 将父节点作为新的当前节点。
									(02) 以新的当前节点为支点进行左旋。</p>
								<p>下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p>
								<p>首先，将父节点作为新的当前节点；接着，以新的当前节点为支点进行左旋。
									为了便于理解，我们先说明第(02)步，再说明第(01)步；为了便于说明，我们设置父节点的代号为F(Father)，当前节点的代号为S(Son)。</p>
								<p>为什么要以F为支点进行左旋呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节点设为黑色。既然是将红色的节点移到根节点，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。
									而S又是一个右孩子，因此，我们可以通过左旋来将S上移！ </p>
								<p>按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为黑色，就完全解决问题了；若S不是根节点，那我们需要执行步骤(01)，即将F设为‘新的当前节点’。那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？这是因为左旋之后，F变成了S的子节点，即S变成了F的父节点；而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，必须先解决孩子的问题，再解决父亲的问题；所以，我们执行步骤(01)：将父节点作为新的当前节点。</p>
								<p>2.3 示意图</p>
								<div><img src="images/Red-Black tree picture/insert2.jpg" width="50%"/></div>
								<p><strong>(Case 3)叔叔是黑色，且当前节点是左孩子</strong></p>
								<p>3.1 现象说明</p>
								<p>当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子。</p>
								<p>3.2 处理策略</p>
								<p>(01) 将父节点设为黑色。
									(02) 将祖父节点设为红色。
									(03) 以祖父节点为支点进行右旋。</p>
								<p>下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p>
								<p>为了便于说明，我们设置当前节点为S(Original-
									Son)，兄弟节点为B(Brother)，叔叔节点为U(Uncle)，父节点为F(Father)，祖父节点为G(Grand-Father)。S和F都是红色，违背了红黑树的特性(4)，我们可以将F由红色变为黑色，就解决了违背‘特性(4)’的问题；但却引起了其它问题：违背特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决所有经过F的分支的黑色节点的个数增加了1的问题呢？
									我们可以通过将G由黑色变成红色，同时以G为支点进行右旋来解决。</p>
								<p>3.3 示意图</p>
								<div><img src="images/Red-Black tree picture/insert3.jpg" width="50%"/></div>
								<p>根据上述解决思路，可以写出如下代码：</p>
								<pre><code>//	Red-Black Tree insertion correction function
//	Call this function after inserting a node (out of balance) into the Red-Black Tree; the purpose is to reshape it into a Red-Black Tree.
template &lt;class T&gt;
void RBTree&lt;T&gt;::insertFixUp(RBTNode&lt;T&gt;* &root, RBTNode&lt;T&gt;* node)
{
    RBTNode&lt;T&gt; *parent, *gparent;

    // If the parent node exists, and the color of the parent node is red
    while ((parent = rb_parent(node)) && rb_is_red(parent))
    {
        gparent = rb_parent(parent);

        //If the parent node is the left child of the grandfather node
        if (parent == gparent->left)
        {
            // Case 1 condition: Uncle node is red
            {
                RBTNode&lt;T&gt; *uncle = gparent->right;
                if (uncle && rb_is_red(uncle))
                {
                    rb_set_black(uncle);
                    rb_set_black(parent);
                    rb_set_red(gparent);
                    node = gparent;
                    continue;
                }
            }

            // Case 2 condition: uncle is black, and the current node is the right child.
            if (parent->right == node)
            {
                RBTNode&lt;T&gt; *tmp;
                leftRotate(root, parent);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            // Case 3 condition: the uncle is black, and the current node is the left child.
            rb_set_black(parent);
            rb_set_red(gparent);
            rightRotate(root, gparent);
        } 
        else//If Z's parent is Z's grandfather's right child.
        {
            // Case 1 condition: Uncle node is red.
            {
                RBTNode&lt;T&gt; *uncle = gparent->left;
                if (uncle && rb_is_red(uncle))
                {
                    rb_set_black(uncle);
                    rb_set_black(parent);
                    rb_set_red(gparent);
                    node = gparent;
                    continue;
                }
            }

            // Case 2 condition: uncle is black, and the current node is the left child.
            if (parent->left == node)
            {
                RBTNode&lt;T&gt; *tmp;
                rightRotate(root, parent);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            // Case 3 condition: the uncle is black, and the current node is the right child.
            rb_set_black(parent);
            rb_set_red(gparent);
            leftRotate(root, gparent);
        }
    }

    // Set the root node to black.
    rb_set_black(root);
}
//	Find the successor node of node (x). That is, the data value in the Red-Black Tree is greater than the minimum node of the node.
template &lt;class T&gt;
RBTNode&lt;T&gt;* RBTree&lt;T&gt;::successor(RBTNode&lt;T&gt; *x)
{
    //  If x has a right child, the successor node of X is the smallest node of the subtree whose root is the right child.
    if (x->right != NULL)
        return minimum(x->right);

    // If x has no right child. Then x has the following two possibilities:
	//(01) x is a left child, then the successor node of X is its parent node.
	//(02) if x is a right child, find the lowest parent node of X, and the parent node must have a left child. The lowest parent node found is the successor node of X.
    RBTNode&lt;T&gt;* y = x->parent;
    while ((y!=NULL) && (x==y->right))
    {
        x = y;
        y = y->parent;
    }

    return y;
} 
// Find the precursor node of node (x). That is, the data value in the Red-Black Tree is less than the maximum node of the node.
template &lt;class T&gt;
RBTNode&lt;T&gt;* RBTree&lt;T&gt;::predecessor(RBTNode&lt;T&gt; *x)
{
    // If x has a left child, the leading node of X is the largest node of the subtree whose root is the left child.
    if (x->left != NULL)
        return maximum(x->left);
    // If x doesn't have a left child. Then x has the following two possibilities:            
	//(01) x is a right child, then the precursor node of X "is its parent node.            
	//(01) if x is a left child, find the lowest parent node of X, and the parent node must have a right child. The "lowest parent node" found is the precursor node of X.
    RBTNode&lt;T&gt;* y = x->parent;
    while ((y!=NULL) && (x==y->left))
    {
        x = y;
        y = y->parent;
    }

    return y;
}
//	Insert node into Red-Black Tree.
template &lt;class T&gt;
void RBTree&lt;T&gt;::insert(RBTNode&lt;T&gt;* &root, RBTNode&lt;T&gt;* node)
{
    RBTNode&lt;T&gt; *y = NULL;
    RBTNode&lt;T&gt; *x = root;

    // 1. Take the Red-Black Tree as a Red-Black Tree, and add the nodes to the Red-Black Tree.
    while (x != NULL)
    {
        y = x;
        if (node->key < x->key)
            x = x->left;
        else
            x = x->right;
    }

    node->parent = y;
    if (y!=NULL)
    {
        if (node->key < y->key)
            y->left = node;
        else
            y->right = node;
    }
    else
        root = node;

    // 2. Set the node color to red.
    node->color = RED;

    // 3. Revise it to a Red-Black Tree.
    insertFixUp(root, node);
}
// Insert the node (key is the node key value) into the Red-Black Tree.
template &lt;class T&gt;
void RBTree&lt;T&gt;::insert(T key)
{
    RBTNode&lt;T&gt; *z=NULL;

    // If the new node fails, return.
    if ((z=new RBTNode&lt;T&gt;(key,BLACK,NULL,NULL,NULL)) == NULL)
        return ;

    insert(mRoot, z);
}</code></pre>
							</div>
						</div>
					</div>
					<div class="bb-item" id="item6">
						<div class="content">
							<div class="scroller">
								<br>
								<h2>红黑树的删除</h2>
								<br><br>
								<p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过&quot;旋转和重新着色&quot;等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：</p>
								<p>第一步：将红黑树当作一颗二叉查找树，将节点删除。
									这和删除常规二叉查找树中删除节点的方法是一样的。共有3种情况：</p>
								<ol>
									<li>被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。</li>
									<li>被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</li>
									<li>被删除节点有两个儿子。那么，先找出它的后继节点；然后把它的后继节点的内容复制给该节点的内容；之后，删除它的后继节点。在这里，后继节点相当于替身，在将后继节点的内容复制给&quot;被删除节点&quot;之后，再将后继节点删除。这样就巧妙的将问题转换为&quot;删除后继节点&quot;的情况了，下面就考虑后继节点。
										在&quot;被删除节点&quot;有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然&quot;的后继节点&quot;不可能双子都非空，就意味着&quot;该节点的后继节点&quot;要么没有儿子，要么只有一个儿子。若没有儿子，则按&quot;情况1
										&quot;进行处理；若只有一个儿子，则按&quot;情况2 &quot;进行处理。</li>
								</ol>
								<p>第二步：通过&quot;旋转和重新着色&quot;等一系列来修正该树，使之重新成为一棵红黑树。
									因为&quot;第一步&quot;中删除节点之后，可能会违背红黑树的特性。所以需要通过&quot;旋转和重新着色&quot;来修正该树，使之重新成为一棵红黑树。</p>
								<p>前面我们将&quot;删除红黑树中的节点&quot;大致分为两步，在第一步中&quot;将红黑树当作一颗二叉查找树，将节点删除&quot;后，可能违反&quot;特性(2)、(4)、(5)&quot;三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。</p>
								<p>为了便于分析，我们假设&quot;x包含一个额外的黑色&quot;(x原本的颜色还存在)，这样就不会违反&quot;特性(5)&quot;。为什么呢？</p>
								<p>通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。
									既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设&quot;x包含一个额外的黑色&quot;，就正好弥补了&quot;删除y所丢失的黑色节点&quot;，也就不会违反&quot;特性(5)&quot;。
									因此，假设&quot;x包含一个额外的黑色&quot;(x原本的颜色还存在)，这样就不会违反&quot;特性(5)&quot;。
									现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是&quot;红+黑&quot;或&quot;黑+黑&quot;，它违反了&quot;特性(1)&quot;。</p>
								<p>现在，我们面临的问题，由解决&quot;违反了特性(2)、(4)、(5)三个特性&quot;转换成了&quot;解决违反特性(1)、(2)、(4)三个特性&quot;。RB-DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是：将x所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：</p>
								<p>a) x指向一个&quot;红+黑&quot;节点。此时，将x设为一个&quot;黑&quot;节点即可。
									b) x指向根。此时，将x设为一个&quot;黑&quot;节点即可。
									c) 非前面两种姿态。</p>
								<p>将上面的姿态，可以概括为3种情况。</p>
								<ol>
									<li>情况说明：x是红+黑节点。
										处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。</li>
									<li>情况说明：x是黑+黑节点，且x是根。
										处理方法：什么都不做，结束。此时红黑树性质全部恢复。</li>
									<li>情况说明：x是黑+黑节点，且x不是根。
										处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示：</li>
								</ol>
								<table frame="border" rules="all">
									<tr align="center">
										<th></th>
										<th>现象说明</th>
										<th>处理策略</th>
									</tr>
									<tr>
										<td>Case 1</td>
										<td>x是黑+黑节点，x的兄弟节点是红色(即此时x的父节点和x的兄弟节点的子节点都是黑节点)</td>
										<td>(1) 将x的兄弟节点设为黑色</br>(2) 将x的父节点设为红色</br>(3) 对x的父节点进行左旋
											</br>(4) 左旋后，重新设置x的兄弟节点</td>
									</tr>
									<tr>
										<td>Case 2</td>
										<td>x是黑+黑节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色</td>
										<td>(1) 将x的兄弟节点设为红色</br>(2) 设置x的父节点为新的x节点</td>
									</tr>
									<tr>
										<td>Case 3</td>
										<td>x是黑+黑节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色</td>
										<td>(1) 将x兄弟节点的左孩子设为黑色</br>(2) 将x兄弟节点设为红色</br>(3) 对x的兄弟节点进行右旋</br> (4) 右旋后，重新设置x的兄弟节点</td>
									</tr>
									<tr>
										<td>Case 4</td>
										<td>x是黑+黑节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</td>
										<td>(1) 将x父节点颜色 赋值给 x的兄弟节点</br>(2) 将x父节点设为黑色</br>(3) 将x兄弟节点的右子节设“黑色</br>(4) 对x的父节点进行左旋</br>
										(5) 设置x为根节点</td>
									</tr>
								</table></br>
								<p><strong>(Case 1)x是&quot;黑+黑&quot;节点，x的兄弟节点是红色</strong></p>
								<p>1.1 现象说明</p>
								<p>x是&quot;黑+黑&quot;节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</p>
								<p>1.2 处理策略</p>
								<p>(01) 将x的兄弟节点设为黑色。
									(02) 将x的父节点设为红色。
									(03) 对x的父节点进行左旋。
									(04) 左旋后，重新设置x的兄弟节点。</p>
								<p>下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p>
								<p>这样做的目的是将Case 1转换为Case 2、Case 3或Case
									4，从而进行进一步的处理。对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前将x的兄弟节点设为黑色，同时将x的父节点设为红色；左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p>
								<p>1.3 示意图</p>
								<div><img src="images/Red-Black tree picture/delete1.jpg" width="50%" /></div>
								<p><strong>(Case 2) x是&quot;黑+黑&quot;节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色</strong>
									2.1 现象说明
									x是黑+黑节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。
									2.2 处理策略
									(01) 将x的兄弟节点设为红色。
									(02) 设置x的父节点为新的x节点。
									下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p>
								<p>这个情况的处理思想：是将x中多余的一个黑色属性上移(往根方向移动)。 x是黑+黑节点，我们将x由黑+黑节点 变成
									黑节点，多余的一个黑属性移到x的父节点中，即x的父节点多出了一个黑属性(若x的父节点原先是黑，则此时变成了黑+黑；若x的父节点原先时红，则此时变成了红+黑)。
									此时，需要注意的是：所有经过x的分支中黑节点个数没变化；但是，所有经过x的兄弟节点的分支中黑色节点的个数增加了1(因为x的父节点多了一个黑色属性)！为了解决这个问题，我们需要将所有经过x的兄弟节点的分支中黑色节点的个数减1即可，那么就可以通过将x的兄弟节点由黑色变成红色来实现。</p>
								<p>经过上面的步骤(将x的兄弟节点设为红色)，多余的一个颜色属性(黑色)已经跑到x的父节点中。我们需要将x的父节点设为新的x节点进行处理。若新的x节点是黑+红，直接将新的x节点设为黑色，即可完全解决该问题；若新的x节点是黑+黑，则需要对新的x节点进行进一步处理。</p>
								<p>2.3 示意图</p>
								<div><img src="images/Red-Black tree picture/delete2.jpg" width="50%"/></div>
								<p><strong>(Case 3)x是黑+黑节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</strong></p>
								<p>3.1 现象说明
									x是黑+黑节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</p>
								<p>3.2 处理策略</p>
								<p>(01) 将x兄弟节点的左孩子设为黑色。
									(02) 将x兄弟节点设为红色。
									(03) 对x的兄弟节点进行右旋。
									(04) 右旋后，重新设置x的兄弟节点。</p>
								<p>下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p>
								<p>我们处理Case 3的目的是为了将Case 3进行转换，转换成Case
									4,从而进行进一步的处理。转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前将x的兄弟节点的左孩子设为黑色，同时将x的兄弟节点设为红色；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p>
								<p>3.3 示意图</p>
								<div><img src="images/Red-Black tree picture/delete3.jpg" width="50%"/></div>
								<p><strong>(Case 4)x是黑+黑节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</strong></p>
								<p>4.1 现象说明</p>
								<p>x是黑+黑节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</p>
								<p>4.2 处理策略</p>
								<p>(01) 将x父节点颜色 赋值给 x的兄弟节点。
									(02) 将x父节点设为黑色。
									(03) 将x兄弟节点的右子节设为黑色。
									(04) 对x的父节点进行左旋。
									(05) 设置x为根节点。</p>
								<p>下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p>
								<p>我们处理Case 4的目的是：去掉x中额外的黑色，将x变成单独的黑色。处理的方式是：进行颜色修改，然后对x的父节点进行左旋。下面，我们来分析是如何实现的。</p>
								<p>为了便于说明，我们设置当前节点为S(Original Son)，兄弟节点为B(Brother)，兄弟节点的左孩子为BLS(Brother&#39;s Left
									Son)，兄弟节点的右孩子为BRS(Brother&#39;s Right Son)，父节点为F(Father)。</p>
								<p>我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了特性(4)；为了解决这一问题，我们将F设置为黑色。
									但是，F设置为黑色之后，为了保证满足特性(5)，即为了保证左旋之后：</p>
								<p>第一，同时经过根节点和S的分支的黑色节点个数不变。</p>
								<p>若满足第一，只需要S丢弃它多余的颜色即可。因为S的颜色是黑+黑，而左旋后同时经过根节点和S的分支的黑色节点个数增加了1；现在，只需将S由黑+黑变成单独的黑节点，即可满足第一。</p>
								<p>第二，同时经过根节点和BLS的分支的黑色节点数不变。</p>
								<p>若满足第二，只需要将F的原始颜色赋值给B即可。之前，我们已经将F设置为黑色(即，将B的颜色&quot;黑色&quot;，赋值给了F)。至此，我们算是调换了F和B的颜色。</p>
								<p>第三，同时经过根节点和BRS的分支的黑色节点数不变。</p>
								<p>在第二已经满足的情况下，若要满足第三，只需要将BRS设置为黑色即可。
									经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</p>
								<p>至此，我们就完成了Case 4的处理。理解Case 4的核心，是了解如何去掉当前节点额外的黑色。</p>
								<p>4.3 示意图</p>
								<div><img src="images/Red-Black tree picture/delete4.jpg" width="50%"/></div>
								<p>根据上述解决思路，可以写出如下代码：</p>
								<pre><code>//This function is called after the insertion node is removed from the Red-Black Tree (the Red-Black Tree is out of balance); 
//the purpose is to reshape it into a Red-Black Tree.
template &lt;class T&gt;
void RBTree&lt;T&gt;::removeFixUp(RBTNode&lt;T&gt;* &root, RBTNode&lt;T&gt; *node, RBTNode&lt;T&gt; *parent)
{
    RBTNode&lt;T&gt; *other;

    while ((!node || rb_is_black(node)) && node != root)
    {
        if (parent->left == node)
        {
            other = parent->right;
            if (rb_is_red(other))
            {
                // Case 1: brother w of X is red
                rb_set_black(other);
                rb_set_red(parent);
                leftRotate(root, parent);
                other = parent->right;
            }
            if ((!other->left || rb_is_black(other->left)) &&
                (!other->right || rb_is_black(other->right)))
            {
                // Case 2: brother w of X is black, and both children of W are black 
                rb_set_red(other);
                node = parent;
                parent = rb_parent(node);
            }
            else
            {
                if (!other->right || rb_is_black(other->right))
                {
                    // Case 3: brother w of X is black, and the left child of W is red, and the right child is black.
                    rb_set_black(other->left);
                    rb_set_red(other);
                    rightRotate(root, other);
                    other = parent->right;
                }
                // Case 4: brother w of X is black, and the right child of W is red, and the left child is any color.
                rb_set_color(other, rb_color(parent));
                rb_set_black(parent);
                rb_set_black(other->right);
                leftRotate(root, parent);
                node = root;
                break;
            }
        }
        else
        {
            other = parent->left;
            if (rb_is_red(other))
            {
                // Case 1: brother w of X is red  
                rb_set_black(other);
                rb_set_red(parent);
                rightRotate(root, parent);
                other = parent->left;
            }
            if ((!other->left || rb_is_black(other->left)) &&
                (!other->right || rb_is_black(other->right)))
            {
                // Case 2: brother w of X is black, and both children of W are black
                rb_set_red(other);
                node = parent;
                parent = rb_parent(node);
            }
            else
            {
                if (!other->left || rb_is_black(other->left))
                {
                    // Case 3: brother w of X is black, and the left child of W is red, and the right child is black.  
                    rb_set_black(other->right);
                    rb_set_red(other);
                    leftRotate(root, other);
                    other = parent->left;
                }
                // Case 4: brother w of X is black, and the right child of W is red, and the left child is any color.
                rb_set_color(other, rb_color(parent));
                rb_set_black(parent);
                rb_set_black(other->left);
                rightRotate(root, parent);
                node = root;
                break;
            }
        }
    }
    if (node)
        rb_set_black(node);
}

// Delete node and return the deleted node.
template &lt;class T&gt;
void RBTree&lt;T&gt;::remove(RBTNode&lt;T&gt;* &root, RBTNode&lt;T&gt; *node)
{
    RBTNode&lt;T&gt; *child, *parent;
    RBTColor color;

    // The left and right children of the deleted node are not empty.
    if ( (node->left!=NULL) && (node->right!=NULL) ) 
    {
        // The successor node of the deleted node. (called replacement node)
        // Use it to replace the "deleted node" position, and then remove the deleted node.
        RBTNode&lt;T&gt; *replace = node;

        // Get successor node
        replace = replace->right;
        while (replace->left != NULL)
            replace = replace->left;

        // Node node is not a root node (only the root node does not have a parent node)
        if (rb_parent(node))
        {
            if (rb_parent(node)->left == node)
                rb_parent(node)->left = replace;
            else
                rb_parent(node)->right = replace;
        } 
        else 
            // Node node is the root node, update the root node.
            root = replace;

        // Child is the right child to replace the node, and also the node to be adjusted.
        // There must be no left child in the replacement node! Because it is a successor node.
        child = replace->right;
        parent = rb_parent(replace);
        // Save the color of the replacement node.
        color = rb_color(replace);

        // The deleted node is the parent of its successor.
        if (parent == node)
        {
            parent = replace;
        } 
        else
        {
            // Child is not empty.
            if (child)
                rb_set_parent(child, parent);
            parent->left = child;

            replace->right = node->right;
            rb_set_parent(node->right, replace);
        }

        replace->parent = node->parent;
        replace->color = node->color;
        replace->left = node->left;
        node->left->parent = replace;

        if (color == BLACK)
            removeFixUp(root, child, parent);

        delete node;
        return ;
    }
    if (node->left !=NULL)
        child = node->left;
    else 
        child = node->right;
    parent = node->parent;
    // Save the color of the replacement node.
    color = node->color;
    if (child)
        child->parent = parent;
    // Node node is not the root node
    if (parent)
    {
        if (parent->left == node)
            parent->left = child;
        else
            parent->right = child;
    }
    else
        root = child;

    if (color == BLACK)
        removeFixUp(root, child, parent);
    delete node;
}

// Delete the node whose key value is key in the Red-Black Tree.
template &lt;class T&gt;
void RBTree&lt;T&gt;::remove(T key)
{
    RBTNode&lt;T&gt; *node; 

    // Find the node corresponding to the key, and delete the node if found.
    if ((node = search(mRoot, key)) != NULL)
        remove(mRoot, node);
}
</code></pre>										
							</div>
						</div>
					</div>
					
					<div class="bb-item" id="item7">
						<div class="content">
							<div class="scroller">
								<br>
								<h2>红黑树的其它操作</h2>
								<br><br>
								<h3>1).打印二叉查找树结点的值</h3>
								<p>将二叉查找树的所有结点值依次打印下来的代码实现如下：</p>
								<pre><code>//Print Red-Black Tree.
template &lt;class T&gt;
void RBTree&lt;T&gt;::print(RBTNode&lt;T&gt;* tree, T key, int direction)
{
    if(tree != NULL)
    {
        if(direction==0)    // Tree is the root node.
            cout &lt;&lt; setw(2) &lt;&lt; tree-&gt;key &lt;&lt; "(B) is root" &lt;&lt; endl;
        else                // Tree is a branch node.
            cout &lt;&lt; setw(2) &lt;&lt; tree-&gt;key &lt;&lt;  (rb_is_red(tree)?"(R)":"(B)") &lt;&lt; " is " &lt;&lt; setw(2) &lt;&lt; key &lt;&lt; "'s "  &lt;&lt; setw(12) &lt;&lt; (direction==1?"right child" : "left child") &lt;&lt; endl;

        print(tree-&gt;left, tree-&gt;key, -1);
        print(tree-&gt;right,tree-&gt;key,  1);
    }
}
template &lt;class T&gt;
void RBTree&lt;T&gt;::print()
{
    if (mRoot != NULL)
        print(mRoot, mRoot->key, 0);
}</code></pre>
								<h3>2).销毁平衡二叉树</h3>
								<p>销毁平衡二叉树的代码如下：</p>
								<pre><code>//Destroy the Red-Black Tree.
template &lt;class T&gt;
void RBTree&lt;T&gt;::destroy(RBTNode&lt;T&gt;* &tree)
{
    if (tree==NULL)
        return ;

    if (tree->left != NULL)
        return destroy(tree->left);
    if (tree->right != NULL)
        return destroy(tree->right);

    delete tree;
    tree=NULL;
}
template &lt;class T&gt;
void RBTree&lt;T&gt;::destroy()
{
    destroy(mRoot);
}</code></pre>
								<h3>3).查找平衡二叉树的最大值和最小值</h3>
								<p>查找平衡二叉树的最小值，代码如下：</p>
								<pre><code>//	Find the minimum node: returns the minimum node of the Red-Black Tree whose tree is the root node.
template &lt;class T&gt;
RBTNode&lt;T&gt;* RBTree&lt;T&gt;::minimum(RBTNode&lt;T&gt;* tree)
{
    if (tree == NULL)
        return NULL;

    while(tree->left != NULL)
        tree = tree->left;
    return tree;
}
template &lt;class T&gt;
T RBTree&lt;T&gt;::minimum()
{
    RBTNode&lt;T&gt; *p = minimum(mRoot);
    if (p != NULL)
        return p->key;

    return (T)NULL;
}
//	Find the maximum node: returns the maximum node of the Red-Black Tree whose tree is the root node.
template &lt;class T&gt;
RBTNode&lt;T&gt;* RBTree&lt;T&gt;::maximum(RBTNode&lt;T&gt;* tree)
{
    if (tree == NULL)
        return NULL;

    while(tree->right != NULL)
        tree = tree->right;
    return tree;
}
template &lt;class T&gt;
T RBTree&lt;T&gt;::maximum()
{
    RBTNode&lt;T&gt; *p = maximum(mRoot);
    if (p != NULL)
        return p->key;

    return (T)NULL;
}</code></pre>
							</div>
						</div>
					</div>
					
					<div class="bb-item" id="item8">
						<div class="content">
							<div class="scroller">
								<br>
								<h2>红黑树的遍历</h2>
								<br><br>
								<h3>(1).先序遍历</h3>
								<p>对于先序遍历来说，总是先访问根结点root，然后才去访问左子树和右子树，因此先序遍历的遍历顺序是根结点-&gt;左子树-&gt;右子树。
									由此可以写出先序遍历的代码：</p>
<pre><code>//	Preorder traversal of Red-Black Tree.
template &lt;class T&gt;
void RBTree&lt;T&gt;::preOrder(RBTNode&lt;T&gt;* tree) const
{
    if(tree != NULL)
    {
        cout<< tree->key << " " ;
        preOrder(tree->left);
        preOrder(tree->right);
    }
}
template &lt;class T&gt;
void RBTree&lt;T&gt;::preOrder() 
{
    preOrder(mRoot);
}</code></pre>									
								<h3>(2).中序遍历</h3>
								<p>对于中序遍历来说，总是先访问左子树，再访问根节点，最后访问右子树，因此中序遍历的遍历顺序是左子树-&gt;根结点-&gt;右子树。<strong>对于二叉查找树进行中序遍历，遍历结果是有序的。</strong>
									由此可以写出中序遍历的代码：</p>
<pre><code>//	Inorder traversal of Red-Black Tree.
template &lt;class T&gt;
void RBTree&lt;T&gt;::inOrder(RBTNode&lt;T&gt;* tree) const
{
    if(tree != NULL)
    {
        inOrder(tree->left);
        cout<< tree->key << " " ;
        inOrder(tree->right);
    }
}
template &lt;class T&gt;
void RBTree&lt;T&gt;::inOrder() 
{
    inOrder(mRoot);
}</code></pre>									
								<h3>(3).后序遍历</h3>
								<p>对于后序遍历来说，总是先访问左子树，再访问右子树，最后访问根节点，因此后序遍历的遍历顺序是左子树-&gt;右子树-&gt;根结点。
									由此可以写出后序遍历的代码：</p>
<pre><code>//Postorder traversal of Red-Black Tree.
template &lt;class T&gt;
void RBTree&lt;T&gt;::postOrder(RBTNode&lt;T&gt;* tree) const
{
    if(tree != NULL)
    {
        postOrder(tree-&gt;left);
        postOrder(tree-&gt;right);
        cout<< tree-&gt;key << " " ;
    }
}
template &lt;class T&gt;
void RBTree&lt;T&gt;::postOrder() 
{
    postOrder(mRoot);
}
#endif</code></pre>
							</div>
						</div>
					</div>
					
				</div>

				<nav>
					<span id="bb-nav-prev">&larr;</span>
					<span id="bb-nav-next">&rarr;</span>
				</nav>

				<span id="tblcontents" class="menu-button">Table of Contents</span>

			</div>

		</div><!-- /container -->
		<script src="../js/jquery-3.1.1.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jScrollPane/2.2.1/script/jquery.jscrollpane.min.js"></script>
		<script src="js/jquery.bookblock.js"></script>
		<script src="js/page.js"></script>
		<script>
			$(function() {
				Page.init();
			});
		</script>
	</body>
</html>
